{
	"nodes":[
		{"id":"d2c3a3515f56cf9e","type":"file","file":"42Malaga/42_Projects/push_swap/my_code/push_swap.c.md","x":-780,"y":-880,"width":880,"height":560},
		{"id":"b4dd924c4bfc027a","type":"text","text":"Main Func:\n\n\n```\nint_array = argument_parser(argc, argv, &arr_size);\n```\nHandles the application arguments. \nargc == 1 : no args given.\nargc == 2:  A single argument, or a string is given. In this case `parse_single_argument` is called. If it is a single digit, nothing is output as no changes are made. If it is a string of values, then the string is split into an array. \nanything more than 2 and the `parse_arguments` is called where the integers are validated and written to an array if they are.\n\nThe array of integers are checked to see if they are already in order, simply iterating through the list ensuring the next value is greater than the current .\n\nStacks `a` and `b` are initialised.\n\nHere improvements can be made to the sorting efficiency, but currently I chose to sort either a *small* list of integers, <5, or  `big` list. \n\nClean up of the memory happens at the end, `free`ing the `int_array` and then calling `free_stack` to free stacks `a` and `b`. ","x":-780,"y":-300,"width":780,"height":320},
		{"id":"a705740a8782f4b9","type":"text","text":"The `initialise_stack` function initializes a stack from an array of integers. It takes an integer array `arr` and its size `size` as parameters. The function creates a **linked list** of `t_stack_node` structures, where each node represents an element in the stack. It iterates through the array in reverse order, allocating memory for each new node and setting its value to the corresponding array element. The new node is then linked to the existing stack, with the head pointer updated to point to the new node. If the array is null or memory allocation fails, the function returns null.\n\nThe `get_lc_node` function retrieves the node with the *lowest cost* from the stack. It moves through the stack starting from the `head` and returns the first node that has the `lowest_cost` flag set to `true`. If no such node is found or if the stack is empty, the function returns `null`. This function is useful for identifying the node with the lowest cost in terms of operations needed for sorting.\n\nThe `push_prep` function prepares the stack for a push operation by rotating or reverse rotating the stack until the specified `top_node` is at the top. It takes a pointer to the stack, the target node `top_node`, and a character `stack_name` indicating which stack ('a' or 'b') is being manipulated. Depending on whether the target node is above or below the median, the function calls the appropriate rotation functions (`ra`, `rra`, `rb`, `rrb`) to move the target node to the top of the stack. This function ensures that the stack is in the correct state for the subsequent push operation.","x":160,"y":-280,"width":780,"height":520},
		{"id":"0419716b70d0ff40","type":"file","file":"42Malaga/42_Projects/push_swap/my_code/init_stack.c.md","x":160,"y":-880,"width":780,"height":560}
	],
	"edges":[]
}